#!/usr/bin/env node

const async = require('async');
const execSync = require('child_process').execSync;
const fs = require('fs');
const program = require('commander');
const debug = require('debug')('meta-npm-link');
const loop = require('loop-things');
const path = require('path');
const util = require('util');

if (process.argv[2] === '--help') {
  return console.log(`\n  usage:\n\n    meta npm link\n`);
}

var meta = null; 
var buffer = null;

const metaLocation = path.join(process.cwd(), '.meta');

try {
  buffer = fs.readFileSync(metaLocation);
  debug(`.meta file found at ${metaLocation}`);
} catch (e) {
  debug(`no .meta file found at ${metaLocation}: ${e}`);
}

if (buffer) {
  try {
    meta = JSON.parse(buffer.toString());
    debug(`.meta file contents parsed: ${util.inspect(meta, null, Infinity)}`);
  } catch (e) {
    debug(`error parsing .meta JSON: ${e}`);
  }
}

const projects = meta.projects;
const folders = Object.keys(projects).map((folder) => { return path.resolve(folder); });

loop({
  command: 'npm link',
  directories: folders
}, (err) => {

  console.log();

  const packageJsons = folders.map((folder) => {
    return require(path.join(folder, 'package.json'));
  });

  const names = packageJsons.map((p) => { return p.name; });

  async.mapSeries(names, (name, cb) => {
    try {
      execSync(`npm link ${name}`, { stdio: 'inherit' });
      console.log();
    } catch (err) {
      return cb(err);
    }
    return cb();
  }, (err) => {
    if (err) throw err;

    console.log('meta npm link complete');

  }); 

});